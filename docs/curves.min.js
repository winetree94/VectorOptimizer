(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["Curves"] = factory();
	else
		root["Curves"] = factory();
})(self, function() {
return /******/ (function() { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/curves.sample/drawer.ts":
/*!*************************************!*\
  !*** ./src/curves.sample/drawer.ts ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Drawer = exports.PreprocessMode = exports.RenderMode = void 0;
/* eslint-disable no-case-declarations */
var curve_fit_1 = __webpack_require__(/*! ../curves/curve-fit */ "./src/curves/curve-fit.ts");
var curve_preprocess_1 = __webpack_require__(/*! ../curves/curve-preprocess */ "./src/curves/curve-preprocess.ts");
var vector_1 = __webpack_require__(/*! ../curves/vector */ "./src/curves/vector.ts");
function getRandomColor() {
    var letters = '0123456789ABCDEF';
    var color = '#';
    for (var i = 0; i < 6; i++) {
        color += letters[Math.floor(Math.random() * 16)];
    }
    return color;
}
var RenderMode;
(function (RenderMode) {
    RenderMode["ORIGINAL_POINTS"] = "original-points";
    RenderMode["ORIGINAL_LINES"] = "original-lines";
    RenderMode["PREPROCESSED"] = "preprocessed";
    RenderMode["CONTROL_POINTS"] = "control-points";
    RenderMode["REPARAMATERIZED"] = "reparamaterized";
    RenderMode["FINAL_CURVES"] = "final-curves";
})(RenderMode = exports.RenderMode || (exports.RenderMode = {}));
var PreprocessMode;
(function (PreprocessMode) {
    PreprocessMode["NONE"] = "none";
    PreprocessMode["LINEARIZE"] = "linearize";
    PreprocessMode["RAMER_DOUGLAS_PEUCHER"] = "ramer-douglas-peucher";
})(PreprocessMode = exports.PreprocessMode || (exports.PreprocessMode = {}));
var Drawer = /** @class */ (function () {
    function Drawer(element) {
        this.element = element;
        this.originPoints = [];
        this._options = {
            preprocessMode: PreprocessMode.NONE,
            renderMode: RenderMode.ORIGINAL_POINTS,
            linearizePointDistance: 8,
            curveFittingError: 8,
            colorize: true,
        };
        element.addEventListener('pointerdown', this.onMouseDown.bind(this));
        element.addEventListener('mousedown', this.onMouseDown.bind(this));
        element.addEventListener('touchstart', function (e) { return e.preventDefault(); });
    }
    Object.defineProperty(Drawer.prototype, "options", {
        get: function () {
            return this._options;
        },
        set: function (options) {
            this._options = __assign(__assign({}, this._options), options);
            this.render();
        },
        enumerable: false,
        configurable: true
    });
    Drawer.prototype.onMouseDown = function (event) {
        var _this = this;
        event.preventDefault();
        this.clearOriginPoints();
        this.clearView();
        var startPoint = {
            x: event.offsetX,
            y: event.offsetY,
        };
        var $startCircle = this.createCircle(startPoint);
        this.element.appendChild($startCircle);
        this.originPoints.push(startPoint);
        var onMouseMove = function (event) {
            var point = {
                x: event.offsetX,
                y: event.offsetY,
            };
            var $circle = _this.createCircle(point);
            _this.element.appendChild($circle);
            _this.originPoints.push(point);
        };
        var onMouseUp = function () {
            _this.element.removeEventListener('pointermove', onMouseMove);
            _this.element.removeEventListener('pointerup', onMouseUp);
            _this.element.removeEventListener('mousemove', onMouseMove);
            _this.element.removeEventListener('mouseup', onMouseUp);
            _this.render();
        };
        this.element.addEventListener('mousemove', onMouseMove);
        this.element.addEventListener('mouseup', onMouseUp);
        this.element.addEventListener('pointermove', onMouseMove);
        this.element.addEventListener('pointerup', onMouseUp);
    };
    Drawer.prototype.createCircle = function (point) {
        var $circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        $circle.setAttribute('cx', point.x.toString());
        $circle.setAttribute('cy', point.y.toString());
        $circle.setAttribute('r', (1).toString());
        $circle.setAttribute('fill', 'red');
        return $circle;
    };
    Drawer.prototype.clearOriginPoints = function () {
        this.originPoints.splice(0);
    };
    Drawer.prototype.clearView = function () {
        this.element.innerHTML = '';
    };
    Drawer.prototype.transformToVector = function () {
        return this.originPoints.map(function (point) { return vector_1.Vector.from(point); });
    };
    Drawer.prototype.getPreprocessedVectors = function () {
        switch (this.options.preprocessMode) {
            case PreprocessMode.NONE:
                return this.transformToVector();
            case PreprocessMode.LINEARIZE:
                return curve_preprocess_1.linearize(this.transformToVector(), this.options.linearizePointDistance);
            case PreprocessMode.RAMER_DOUGLAS_PEUCHER:
                return this.transformToVector();
        }
    };
    Drawer.prototype.render = function () {
        var _this = this;
        switch (this.options.renderMode) {
            case RenderMode.ORIGINAL_POINTS:
                this.clearView();
                this.originPoints.forEach(function (point) {
                    var $circle = _this.createCircle(point);
                    _this.element.appendChild($circle);
                });
                break;
            case RenderMode.ORIGINAL_LINES:
                this.clearView();
                for (var i = 1; i < this.originPoints.length; i++) {
                    var previous = this.originPoints[i - 1];
                    var current = this.originPoints[i];
                    var $polyline = document.createElementNS('http://www.w3.org/2000/svg', 'polyline');
                    $polyline.setAttribute('fill', 'none');
                    $polyline.setAttribute('stroke', this.options.colorize ? getRandomColor() : 'red');
                    $polyline.setAttribute('points', previous.x + " " + previous.y + " " + current.x + ", " + current.y);
                    this.element.appendChild($polyline);
                }
                break;
            case RenderMode.PREPROCESSED:
                this.clearView();
                this.getPreprocessedVectors().forEach(function (vector) {
                    var $circle = _this.createCircle(vector);
                    _this.element.appendChild($circle);
                });
                break;
            case RenderMode.FINAL_CURVES:
                this.clearView();
                var $path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                $path.setAttribute('fill', 'none');
                $path.setAttribute('stroke', 'red');
                var curveFit = new curve_fit_1.CurveFit(this.getPreprocessedVectors()
                // ExpectedLinearizedSample.map((point) => Vector.from(point))
                );
                curveFit.fit(this.options.curveFittingError).forEach(function (bezier) {
                    var $path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    $path.setAttribute('fill', 'none');
                    $path.setAttribute('stroke', _this.options.colorize ? getRandomColor() : 'red');
                    $path.setAttribute('stroke-width', 2 + "px");
                    $path.setAttribute('d', "M " + bezier.p0.x + " " + bezier.p0.y + " C " + bezier.p1.x + " " + bezier.p1.y + " " + bezier.p2.x + " " + bezier.p2.y + " " + bezier.p3.x + " " + bezier.p3.y);
                    _this.element.appendChild($path);
                });
                break;
        }
    };
    return Drawer;
}());
exports.Drawer = Drawer;


/***/ }),

/***/ "./src/curves/cubic-bezier.ts":
/*!************************************!*\
  !*** ./src/curves/cubic-bezier.ts ***!
  \************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CubicBezier = void 0;
var vector_1 = __webpack_require__(/*! ./vector */ "./src/curves/vector.ts");
var CubicBezier = /** @class */ (function () {
    function CubicBezier(p0, p1, p2, p3) {
        this.p0 = p0;
        this.p1 = p1;
        this.p2 = p2;
        this.p3 = p3;
    }
    CubicBezier.from = function (cubicBezierLike) {
        return new CubicBezier(vector_1.Vector.from(cubicBezierLike.p0), vector_1.Vector.from(cubicBezierLike.p1), vector_1.Vector.from(cubicBezierLike.p2), vector_1.Vector.from(cubicBezierLike.p3));
    };
    CubicBezier.prototype.sample = function (t) {
        var ti = 1 - t;
        var t0 = ti * ti * ti;
        var t1 = 3 * ti * ti * t;
        var t2 = 3 * ti * t * t;
        var t3 = t * t * t;
        return this.p0
            .multiply(t0)
            .add(this.p1.multiply(t1))
            .add(this.p2.multiply(t2))
            .add(this.p3.multiply(t3));
    };
    return CubicBezier;
}());
exports.CubicBezier = CubicBezier;


/***/ }),

/***/ "./src/curves/curve-fit-base.ts":
/*!**************************************!*\
  !*** ./src/curves/curve-fit-base.ts ***!
  \**************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CurveFitBase = void 0;
var cubic_bezier_1 = __webpack_require__(/*! ./cubic-bezier */ "./src/curves/cubic-bezier.ts");
var vector_1 = __webpack_require__(/*! ./vector */ "./src/curves/vector.ts");
// Copyright (c) 2015 burningmime
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//    claim that you wrote the original software. If you use this software
//    in a product, an acknowledgement in the product documentation would be
//    appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//    misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.
var MAX_ITERS = 4;
var END_TANGENT_N_PTS = 8;
var MID_TANGENT_N_PTS = 4;
var CurveFitBase = /** @class */ (function () {
    function CurveFitBase() {
        this._u = [];
        this._squaredError = 0;
    }
    CurveFitBase.prototype.fitCurve = function (first, last, tanL, tanR, curve, split) {
        var result = {
            response: false,
            split: split,
            curve: curve,
        };
        var pts = this._pts;
        var nPts = last - first + 1;
        if (nPts < 2) {
            throw new Error('INTERNAL ERROR: Should always have at least 2 points here');
        }
        else if (nPts == 2) {
            var p0 = pts[first];
            var p3 = pts[last];
            var alpha = p0.distance(p3) / 3;
            var p1 = tanL.multiply(alpha).add(p0);
            var p2 = tanR.multiply(alpha).add(p3);
            curve = new cubic_bezier_1.CubicBezier(p0, p1, p2, p3);
            result.curve = curve;
            split = 0;
            result.split = split;
            result.response = true;
            return result;
        }
        else {
            split = 0;
            result.split = split;
            this.arcLengthParamaterize(first, last);
            curve = null;
            result.curve = curve;
            for (var i = 0; i < MAX_ITERS + 1; i++) {
                if (i != 0) {
                    this.reparameterize(first, last, curve);
                }
                curve = this.generateBezier(first, last, tanL, tanR);
                result.curve = curve;
                var res = this.findMaxSquaredError(first, last, curve, result.split);
                result.split = res.split;
                if (res.response < this._squaredError) {
                    result.response = true;
                    return result;
                }
            }
            result.response = false;
            return result;
        }
    };
    CurveFitBase.prototype.findMaxSquaredError = function (first, last, curve, split) {
        if (curve === void 0) { curve = null; }
        if (split === void 0) { split = 0; }
        var result = {
            response: 0,
            split: split,
        };
        var pts = this._pts;
        var u = this._u;
        var s = (last - first + 1) / 2;
        var nPts = last - first + 1;
        var max = 0;
        for (var i = 1; i < nPts; i++) {
            var v0 = pts[first + i];
            var v1 = curve.sample(u[i]);
            var d = v0.distanceSquared(v1);
            if (d > max) {
                max = d;
                s = i;
            }
        }
        split = s + first;
        if (split <= first)
            split = first + 1;
        if (split >= last)
            split = last - 1;
        result.split = split;
        result.response = max;
        return result;
    };
    CurveFitBase.prototype.generateBezier = function (first, last, tanL, tanR) {
        var pts = this._pts;
        var u = this._u;
        var nPts = last - first + 1;
        var p0 = pts[first];
        var p3 = pts[last];
        var c00 = 0;
        var c01 = 0;
        var c11 = 0;
        var x0 = 0;
        var x1 = 0;
        for (var i = 1; i < nPts; i++) {
            var t = u[i];
            var ti = 1 - t;
            var t0 = ti * ti * ti;
            var t1 = 3 * ti * ti * t;
            var t2 = 3 * ti * t * t;
            var t3 = t * t * t;
            var s = p0
                .multiply(t0)
                .add(p0.multiply(t1))
                .add(p3.multiply(t2))
                .add(p3.multiply(t3));
            var v = pts[first + i].subtract(s);
            var a0 = tanL.multiply(t1);
            var a1 = tanR.multiply(t2);
            c00 += a0.dot(a0);
            c01 += a0.dot(a1);
            c11 += a1.dot(a1);
            x0 += a0.dot(v);
            x1 += a1.dot(v);
        }
        var det_C0_C1 = c00 * c11 - c01 * c01;
        var det_C0_X = c00 * x1 - c01 * x0;
        var det_X_C1 = x0 * c11 - x1 * c01;
        var alphaL = det_X_C1 / det_C0_C1;
        var alphaR = det_C0_X / det_C0_C1;
        var linDist = p0.distance(p3);
        var epsilon2 = Number.EPSILON * linDist;
        if (Math.abs(det_C0_C1) < Number.EPSILON ||
            alphaL < epsilon2 ||
            alphaR < epsilon2) {
            var alpha = linDist / 3;
            var p1 = tanL.multiply(alpha).add(p0);
            var p2 = tanR.multiply(alpha).add(p3);
            return new cubic_bezier_1.CubicBezier(p0, p1, p2, p3);
        }
        else {
            var p1 = tanL.multiply(alphaL).add(p0);
            var p2 = tanR.multiply(alphaR).add(p3);
            return new cubic_bezier_1.CubicBezier(p0, p1, p2, p3);
        }
    };
    CurveFitBase.prototype.reparameterize = function (first, last, curve) {
        var pts = this._pts;
        var u = this._u;
        var nPts = last - first;
        for (var i = 1; i < nPts; i++) {
            var p = pts[first + i];
            var t = u[i];
            var ti = 1 - t;
            var qp0 = curve.p1.subtract(curve.p0).multiply(3);
            var qp1 = curve.p2.subtract(curve.p1).multiply(3);
            var qp2 = curve.p3.subtract(curve.p2).multiply(3);
            var qpp0 = qp1.subtract(qp0).multiply(2);
            var qpp1 = qp2.subtract(qp1).multiply(2);
            var p0 = curve.sample(t);
            var p1 = qp0
                .multiply(ti * ti)
                .add(qp1.multiply(2 * ti * t))
                .add(qp2.multiply(t * t));
            var p2 = qpp0.multiply(ti).add(qpp1.multiply(t));
            var num = (p0.x - p.x) * p1.x + (p0.y - p.y) * p1.y;
            var den = p1.x * p1.x + p1.y * p1.y + (p0.x - p.x) * p2.x + (p0.y - p.y) * p2.y;
            var newU = t - num / den;
            if (Math.abs(den) > Number.EPSILON && newU >= 0 && newU <= 1) {
                u[i] = newU;
            }
        }
    };
    CurveFitBase.prototype.arcLengthParamaterize = function (first, last) {
        var arclen = this._arclen;
        var u = this._u;
        u.splice(0);
        var diff = arclen[last] - arclen[first];
        var start = arclen[first];
        var nPts = last - first;
        u.push(0);
        for (var i = 1; i < nPts; i++) {
            u.push((arclen[first + i] - start) / diff);
        }
        u.push(1);
    };
    CurveFitBase.prototype.getLeftTangent = function (last) {
        var pts = this._pts;
        var arclen = this._arclen;
        var totalLen = arclen[arclen.length - 1];
        var p0 = pts[0];
        var tanL = pts[1].subtract(p0).normalize();
        var total = tanL;
        var weightTotal = 1;
        last = Math.min(END_TANGENT_N_PTS, last - 1);
        for (var i = 2; i <= last; i++) {
            var ti = 1 - arclen[i] / totalLen;
            var weight = ti * ti * ti;
            var v = pts[i].subtract(p0).normalize();
            total = total.add(v.multiply(weight));
            weightTotal += weight;
        }
        if (total.length() > Number.EPSILON) {
            tanL = total.divide(weightTotal).normalize();
        }
        return tanL;
    };
    CurveFitBase.prototype.getRightTangent = function (first) {
        var pts = this._pts;
        var arclen = this._arclen;
        var totalLen = arclen[arclen.length - 1];
        var p3 = pts[pts.length - 1];
        var tanR = pts[pts.length - 2].subtract(p3).normalize();
        var total = tanR;
        var weightTotal = 1;
        first = Math.max(pts.length - (END_TANGENT_N_PTS + 1), first + 1);
        for (var i = pts.length - 3; i >= first; i--) {
            var t = arclen[i] / totalLen;
            var weight = t * t * t;
            var v = pts[i].subtract(p3).normalize();
            total = total.add(v.multiply(weight));
            weightTotal += weight;
        }
        if (total.length() > Number.EPSILON) {
            tanR = total.divide(weightTotal).normalize();
        }
        return tanR;
    };
    CurveFitBase.prototype.getCenterTangent = function (first, last, split) {
        var pts = this._pts;
        var arclen = this._arclen;
        var splitLen = arclen[split];
        var pSplit = pts[split];
        var firstLen = arclen[first];
        var partLen = splitLen - firstLen;
        var total = new vector_1.Vector(0, 0);
        var weightTotal = 0;
        for (var i = Math.max(first, split - MID_TANGENT_N_PTS); i < split; i++) {
            var t = (arclen[i] - firstLen) / partLen;
            var weight = t * t * t;
            var v = pts[i].subtract(pSplit).normalize();
            total = total.add(v.multiply(weight));
            weightTotal += weight;
        }
        var tanL = total.length() > Number.EPSILON && weightTotal > Number.EPSILON
            ? total.divide(weightTotal).normalize()
            : pts[split - 1].subtract(pSplit).normalize();
        partLen = arclen[last] - splitLen;
        var rMax = Math.min(last, split + MID_TANGENT_N_PTS);
        total = new vector_1.Vector(0, 0);
        weightTotal = 0;
        for (var i = split + 1; i <= rMax; i++) {
            var ti = 1 - (arclen[i] - splitLen) / partLen;
            var weight = ti * ti * ti;
            var v = pSplit.subtract(pts[i]).normalize();
            total = total.add(v.multiply(weight));
            weightTotal += weight;
        }
        var tanR = total.length() > Number.EPSILON && weightTotal > Number.EPSILON
            ? total.divide(weightTotal).normalize()
            : pSplit.subtract(pts[split + 1]).normalize();
        total = tanL.add(tanR);
        if (total.lengthSquared() < Number.EPSILON) {
            tanL = pts[split - 1].subtract(pSplit).normalize();
            tanR = pSplit.subtract(pts[split + 1]).normalize();
            total = tanL.add(tanR);
            return total.lengthSquared() < Number.EPSILON
                ? tanL
                : total.divide(2).normalize();
        }
        else {
            return total.divide(2).normalize();
        }
    };
    return CurveFitBase;
}());
exports.CurveFitBase = CurveFitBase;


/***/ }),

/***/ "./src/curves/curve-fit.ts":
/*!*********************************!*\
  !*** ./src/curves/curve-fit.ts ***!
  \*********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CurveFit = exports.generateArcLengths = exports.fit = void 0;
var curve_fit_base_1 = __webpack_require__(/*! ./curve-fit-base */ "./src/curves/curve-fit-base.ts");
var vector_1 = __webpack_require__(/*! ./vector */ "./src/curves/vector.ts");
// Copyright (c) 2015 burningmime
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//    claim that you wrote the original software. If you use this software
//    in a product, an acknowledgement in the product documentation would be
//    appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//    misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.
var END_TANGENT_N_PTS = 8;
var NO_CURVES = [];
function fit(points) {
    var arcLen = generateArcLengths(points);
    return [];
}
exports.fit = fit;
function generateArcLengths(points) {
    var results = [];
    results.push(0);
    var clen = 0;
    var pp = points[0];
    for (var i = 1; i < points.length; i++) {
        var np = points[i];
        clen += vector_1.Vector.from(pp).distance(vector_1.Vector.from(np));
        results.push(clen);
        pp = np;
    }
    return results;
}
exports.generateArcLengths = generateArcLengths;
var CurveFit = /** @class */ (function (_super) {
    __extends(CurveFit, _super);
    function CurveFit(_pts) {
        var _this = _super.call(this) || this;
        _this._pts = _pts;
        _this._result = [];
        var arclen = [];
        arclen.push(0);
        var clen = 0;
        var pp = _this._pts[0];
        for (var i = 1; i < _this._pts.length; i++) {
            var np = _this._pts[i];
            clen += vector_1.Vector.from(pp).distance(vector_1.Vector.from(np));
            arclen.push(clen);
            pp = np;
        }
        _this._arclen = arclen;
        return _this;
    }
    CurveFit.prototype.fit = function (maxError) {
        if (maxError < Number.EPSILON) {
            throw new Error('maxError cannot be negative/zero/less than epsilon value');
        }
        if (!this._pts) {
            throw new Error('points');
        }
        if (this._pts.length < 2) {
            return NO_CURVES;
        }
        this._squaredError = maxError * maxError;
        var last = this._pts.length - 1;
        var tanL = this.getLeftTangent(last);
        var tanR = this.getRightTangent(0);
        this.fitRecursive(0, last, tanL, tanR);
        return this._result;
    };
    CurveFit.prototype.fitRecursive = function (first, last, tanL, tanR) {
        if (first === void 0) { first = 0; }
        if (last === void 0) { last = 0; }
        var split = 0;
        var curve = null;
        var fitCurveResult = this.fitCurve(first, last, tanL, tanR, curve, split);
        split = fitCurveResult.split;
        curve = fitCurveResult.curve;
        if (fitCurveResult.response) {
            this._result.push(curve);
        }
        else {
            var tanM1 = this.getCenterTangent(first, last, split);
            var tanM2 = new vector_1.Vector(-tanM1.x, -tanM1.y);
            if (first == 0 && split < END_TANGENT_N_PTS) {
                tanL = this.getLeftTangent(split);
            }
            if (last == this._pts.length - 1 &&
                split > this._pts.length - (END_TANGENT_N_PTS + 1)) {
                tanR = this.getRightTangent(split);
            }
            // do actual recursion
            this.fitRecursive(first, split, tanL, tanM1);
            this.fitRecursive(split, last, tanM2, tanR);
        }
    };
    return CurveFit;
}(curve_fit_base_1.CurveFitBase));
exports.CurveFit = CurveFit;


/***/ }),

/***/ "./src/curves/curve-preprocess.ts":
/*!****************************************!*\
  !*** ./src/curves/curve-preprocess.ts ***!
  \****************************************/
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.removeDuplicates = exports.linearize = void 0;
// Copyright (c) 2015 burningmime
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//    claim that you wrote the original software. If you use this software
//    in a product, an acknowledgement in the product documentation would be
//    appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//    misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.
function linearize(src, minDistance, alwaysKeepLastVertex, alwaysLinearizeAllVertexes) {
    if (alwaysKeepLastVertex === void 0) { alwaysKeepLastVertex = false; }
    if (alwaysLinearizeAllVertexes === void 0) { alwaysLinearizeAllVertexes = true; }
    var dist = [];
    if (src === null) {
        throw new Error('Source vector array is null');
    }
    if (minDistance <= Number.EPSILON) {
        throw new Error("md " + minDistance + "' is be less than epsilon " + Number.EPSILON);
    }
    if (src.length > 0) {
        var pp = src[0];
        dist.push(pp);
        var cd = 0;
        for (var ip = 1; ip < src.length; ip++) {
            var p0 = src[ip - 1];
            var p1 = src[ip];
            var td = p0.distance(p1);
            if (cd + td > minDistance) {
                var pd = minDistance - cd;
                dist.push(p0.lerp(p1, pd / td));
                var rd = td - pd;
                while (rd > minDistance) {
                    rd -= minDistance;
                    if (alwaysLinearizeAllVertexes) {
                        var np = p0.lerp(p1, (td - rd) / td);
                        if (!np.equalsOrClose(pp)) {
                            dist.push(np);
                            pp = np;
                        }
                    }
                }
                cd = rd;
            }
            else {
                cd += td;
            }
        }
        var lp = src[src.length - 1];
        if (alwaysKeepLastVertex || !pp.equalsOrClose(lp)) {
            dist.push(lp);
        }
    }
    return dist;
}
exports.linearize = linearize;
function removeDuplicates(pts) {
    if (pts.length < 2) {
        return pts;
    }
    var prev = pts[0];
    var len = pts.length;
    var nDup = 0;
    for (var i = 1; i < len; i++) {
        var cur = pts[i];
        if (prev.equalsOrClose(cur))
            nDup++;
        else
            prev = cur;
    }
    if (nDup == 0) {
        return pts;
    }
    else {
        var dst = [];
        prev = pts[0];
        dst.push(prev);
        for (var i = 1; i < len; i++) {
            var cur = pts[i];
            if (!prev.equalsOrClose(cur)) {
                dst.push(cur);
                prev = cur;
            }
        }
        return dst;
    }
}
exports.removeDuplicates = removeDuplicates;


/***/ }),

/***/ "./src/curves/vector.ts":
/*!******************************!*\
  !*** ./src/curves/vector.ts ***!
  \******************************/
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Vector = void 0;
var Vector = /** @class */ (function () {
    function Vector(x, y) {
        this.x = x;
        this.y = y;
    }
    Vector.from = function (point) {
        return new Vector(point.x, point.y);
    };
    Vector.prototype.add = function (a) {
        return new Vector(this.x + (a instanceof Vector ? a.x : a), this.y + (a instanceof Vector ? a.y : a));
    };
    Vector.prototype.subtract = function (a) {
        return new Vector(this.x - (a instanceof Vector ? a.x : a), this.y - (a instanceof Vector ? a.y : a));
    };
    Vector.prototype.multiply = function (a) {
        return new Vector(this.x * (a instanceof Vector ? a.x : a), this.y * (a instanceof Vector ? a.y : a));
    };
    Vector.prototype.divide = function (a) {
        return new Vector(this.x / (a instanceof Vector ? a.x : a), this.y / (a instanceof Vector ? a.y : a));
    };
    Vector.prototype.distance = function (a) {
        return Math.sqrt(this.distanceSquared(a));
    };
    Vector.prototype.distanceSquared = function (a) {
        var x = this.x - a.x;
        var y = this.y - a.y;
        return x * x + y * y;
    };
    Vector.prototype.lerp = function (v, fraction) {
        return new Vector(this.x + (v.x - this.x) * fraction, this.y + (v.y - this.y) * fraction);
    };
    Vector.prototype.equalsOrClose = function (a) {
        return this.distanceSquared(a) < Number.EPSILON;
    };
    Vector.prototype.dot = function (a) {
        return this.x * a.x + this.y * a.y;
    };
    Vector.prototype.lengthSquared = function () {
        return this.x * this.x + this.y * this.y;
    };
    Vector.prototype.length = function () {
        return Math.sqrt(this.x * this.x + this.y * this.y);
    };
    Vector.prototype.normalize = function () {
        return this.divide(this.length());
    };
    return Vector;
}());
exports.Vector = Vector;


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
!function() {
var exports = __webpack_exports__;
/*!***********************************!*\
  !*** ./src/curves.sample/main.ts ***!
  \***********************************/

Object.defineProperty(exports, "__esModule", ({ value: true }));
var drawer_1 = __webpack_require__(/*! ./drawer */ "./src/curves.sample/drawer.ts");
var $svg = document.getElementById('svg-root');
var preprocessMode = drawer_1.PreprocessMode.NONE;
var renderMode = drawer_1.RenderMode.ORIGINAL_POINTS;
var colorize = true;
var linearizePointDistance = 8;
var ramerDouglaspeucherError = 1;
var curveFittingError = 8;
var $preprocessModes = document.getElementsByName('preprocess-mode');
$preprocessModes.forEach(function ($preprocessMode) {
    return $preprocessMode.addEventListener('click', function (e) {
        var target = e.target;
        if (target.checked) {
            preprocessMode = target.value;
            onValueChanged();
        }
    });
});
var $renderModes = document.getElementsByName('render-mode');
$renderModes.forEach(function ($renderMode) {
    return $renderMode.addEventListener('click', function (e) {
        var target = e.target;
        if (target.checked) {
            renderMode = target.value;
            onValueChanged();
        }
    });
});
var $colorize = document.getElementById('colorize');
$colorize.addEventListener('click', function (e) {
    colorize = !!$colorize.checked;
    onValueChanged();
});
var $linearizePointDistanceDisplay = document.getElementById('linearize-point-distance');
var $linearizePointDistance = document.getElementById('linearize-point-distance-slider');
$linearizePointDistance.addEventListener('input', function (e) {
    var target = e.target;
    var value = Number(target.value);
    $linearizePointDistanceDisplay.innerHTML = target.value;
    linearizePointDistance = value;
    onValueChanged();
});
var $curveFittingErrorDisplay = document.getElementById('curve-fitting-error');
var $curveFittingError = document.getElementById('curve-fitting-error-slider');
$curveFittingError.addEventListener('input', function (e) {
    var target = e.target;
    var value = Number(target.value);
    $curveFittingErrorDisplay.innerHTML = target.value;
    curveFittingError = value;
    onValueChanged();
});
var $ramerDouglaspeucherErrorDisplay = document.getElementById('ramer-douglas-peucher-error');
var $ramerDouglaspeucherError = document.getElementById('ramer-douglas-peucher-error-slider');
$ramerDouglaspeucherError.addEventListener('input', function (e) {
    var target = e.target;
    var value = Number(target.value);
    $ramerDouglaspeucherErrorDisplay.innerHTML = target.value;
    ramerDouglaspeucherError = value;
    onValueChanged();
});
var drawer = new drawer_1.Drawer($svg);
function onValueChanged() {
    drawer.options = {
        renderMode: renderMode,
        preprocessMode: preprocessMode,
        linearizePointDistance: linearizePointDistance,
        curveFittingError: curveFittingError,
        colorize: colorize,
    };
}

}();
/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=curves.min.js.map