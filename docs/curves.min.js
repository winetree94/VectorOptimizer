(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["Curves"] = factory();
	else
		root["Curves"] = factory();
})(self, function() {
return /******/ (function() { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/curves/cubic-bezier.ts":
/*!************************************!*\
  !*** ./src/curves/cubic-bezier.ts ***!
  \************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CubicBezier = void 0;
var vector_1 = __webpack_require__(/*! ./vector */ "./src/curves/vector.ts");
var CubicBezier = /** @class */ (function () {
    function CubicBezier(p0, p1, p2, p3) {
        this.p0 = p0;
        this.p1 = p1;
        this.p2 = p2;
        this.p3 = p3;
    }
    CubicBezier.from = function (cubicBezierLike) {
        return new CubicBezier(vector_1.Vector.from(cubicBezierLike.p0), vector_1.Vector.from(cubicBezierLike.p1), vector_1.Vector.from(cubicBezierLike.p2), vector_1.Vector.from(cubicBezierLike.p3));
    };
    CubicBezier.prototype.sample = function (t) {
        var ti = 1 - t;
        var t0 = ti * ti * ti;
        var t1 = 3 * ti * ti * t;
        var t2 = 3 * ti * t * t;
        var t3 = t * t * t;
        return this.p0
            .multiply(t0)
            .add(this.p1.multiply(t1))
            .add(this.p2.multiply(t2))
            .add(this.p3.multiply(t3));
    };
    return CubicBezier;
}());
exports.CubicBezier = CubicBezier;


/***/ }),

/***/ "./src/curves/curve-fit-base.ts":
/*!**************************************!*\
  !*** ./src/curves/curve-fit-base.ts ***!
  \**************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CurveFitBase = void 0;
var cubic_bezier_1 = __webpack_require__(/*! ./cubic-bezier */ "./src/curves/cubic-bezier.ts");
var vector_1 = __webpack_require__(/*! ./vector */ "./src/curves/vector.ts");
// Copyright (c) 2015 burningmime
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//    claim that you wrote the original software. If you use this software
//    in a product, an acknowledgement in the product documentation would be
//    appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//    misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.
var MAX_ITERS = 4;
var END_TANGENT_N_PTS = 8;
var MID_TANGENT_N_PTS = 4;
var CurveFitBase = /** @class */ (function () {
    function CurveFitBase() {
        this._u = [];
        this._squaredError = 0;
    }
    CurveFitBase.prototype.fitCurve = function (first, last, tanL, tanR, curve, split) {
        var result = {
            response: false,
            split: split,
            curve: curve,
        };
        var pts = this._pts;
        var nPts = last - first + 1;
        if (nPts < 2) {
            throw new Error('INTERNAL ERROR: Should always have at least 2 points here');
        }
        else if (nPts == 2) {
            var p0 = pts[first];
            var p3 = pts[last];
            var alpha = p0.distance(p3) / 3;
            var p1 = tanL.multiply(alpha).add(p0);
            var p2 = tanR.multiply(alpha).add(p3);
            curve = new cubic_bezier_1.CubicBezier(p0, p1, p2, p3);
            result.curve = curve;
            split = 0;
            result.split = split;
            result.response = true;
            return result;
        }
        else {
            split = 0;
            result.split = split;
            this.arcLengthParamaterize(first, last);
            curve = null;
            result.curve = curve;
            for (var i = 0; i < MAX_ITERS + 1; i++) {
                if (i != 0) {
                    this.reparameterize(first, last, curve);
                }
                curve = this.generateBezier(first, last, tanL, tanR);
                result.curve = curve;
                var res = this.findMaxSquaredError(first, last, curve, result.split);
                result.split = res.split;
                if (res.response < this._squaredError) {
                    result.response = true;
                    return result;
                }
            }
            result.response = false;
            return result;
        }
    };
    CurveFitBase.prototype.findMaxSquaredError = function (first, last, curve, split) {
        if (curve === void 0) { curve = null; }
        if (split === void 0) { split = 0; }
        var result = {
            response: 0,
            split: split,
        };
        var pts = this._pts;
        var u = this._u;
        var s = (last - first + 1) / 2;
        var nPts = last - first + 1;
        var max = 0;
        for (var i = 1; i < nPts; i++) {
            var v0 = pts[first + i];
            var v1 = curve.sample(u[i]);
            var d = v0.distanceSquared(v1);
            if (d > max) {
                max = d;
                s = i;
            }
        }
        split = s + first;
        if (split <= first)
            split = first + 1;
        if (split >= last)
            split = last - 1;
        result.split = split;
        result.response = max;
        return result;
    };
    CurveFitBase.prototype.generateBezier = function (first, last, tanL, tanR) {
        var pts = this._pts;
        var u = this._u;
        var nPts = last - first + 1;
        var p0 = pts[first];
        var p3 = pts[last];
        var c00 = 0;
        var c01 = 0;
        var c11 = 0;
        var x0 = 0;
        var x1 = 0;
        for (var i = 1; i < nPts; i++) {
            var t = u[i];
            var ti = 1 - t;
            var t0 = ti * ti * ti;
            var t1 = 3 * ti * ti * t;
            var t2 = 3 * ti * t * t;
            var t3 = t * t * t;
            var s = p0
                .multiply(t0)
                .add(p0.multiply(t1))
                .add(p3.multiply(t2))
                .add(p3.multiply(t3));
            var v = pts[first + i].subtract(s);
            var a0 = tanL.multiply(t1);
            var a1 = tanR.multiply(t2);
            c00 += a0.dot(a0);
            c01 += a0.dot(a1);
            c11 += a1.dot(a1);
            x0 += a0.dot(v);
            x1 += a1.dot(v);
        }
        var det_C0_C1 = c00 * c11 - c01 * c01;
        var det_C0_X = c00 * x1 - c01 * x0;
        var det_X_C1 = x0 * c11 - x1 * c01;
        var alphaL = det_X_C1 / det_C0_C1;
        var alphaR = det_C0_X / det_C0_C1;
        var linDist = p0.distance(p3);
        var epsilon2 = Number.EPSILON * linDist;
        if (Math.abs(det_C0_C1) < Number.EPSILON ||
            alphaL < epsilon2 ||
            alphaR < epsilon2) {
            var alpha = linDist / 3;
            var p1 = tanL.multiply(alpha).add(p0);
            var p2 = tanR.multiply(alpha).add(p3);
            return new cubic_bezier_1.CubicBezier(p0, p1, p2, p3);
        }
        else {
            var p1 = tanL.multiply(alphaL).add(p0);
            var p2 = tanR.multiply(alphaR).add(p3);
            return new cubic_bezier_1.CubicBezier(p0, p1, p2, p3);
        }
    };
    CurveFitBase.prototype.reparameterize = function (first, last, curve) {
        var pts = this._pts;
        var u = this._u;
        var nPts = last - first;
        for (var i = 1; i < nPts; i++) {
            var p = pts[first + i];
            var t = u[i];
            var ti = 1 - t;
            var qp0 = curve.p1.subtract(curve.p0).multiply(3);
            var qp1 = curve.p2.subtract(curve.p1).multiply(3);
            var qp2 = curve.p3.subtract(curve.p2).multiply(3);
            var qpp0 = qp1.subtract(qp0).multiply(2);
            var qpp1 = qp2.subtract(qp1).multiply(2);
            var p0 = curve.sample(t);
            var p1 = qp0
                .multiply(ti * ti)
                .add(qp1.multiply(2 * ti * t))
                .add(qp2.multiply(t * t));
            var p2 = qpp0.multiply(ti).add(qpp1.multiply(t));
            var num = (p0.x - p.x) * p1.x + (p0.y - p.y) * p1.y;
            var den = p1.x * p1.x + p1.y * p1.y + (p0.x - p.x) * p2.x + (p0.y - p.y) * p2.y;
            var newU = t - num / den;
            if (Math.abs(den) > Number.EPSILON && newU >= 0 && newU <= 1) {
                u[i] = newU;
            }
        }
    };
    CurveFitBase.prototype.arcLengthParamaterize = function (first, last) {
        var arclen = this._arclen;
        var u = this._u;
        u.splice(0);
        var diff = arclen[last] - arclen[first];
        var start = arclen[first];
        var nPts = last - first;
        u.push(0);
        for (var i = 1; i < nPts; i++) {
            u.push((arclen[first + i] - start) / diff);
        }
        u.push(1);
    };
    CurveFitBase.prototype.getLeftTangent = function (last) {
        var pts = this._pts;
        var arclen = this._arclen;
        var totalLen = arclen[arclen.length - 1];
        var p0 = pts[0];
        var tanL = pts[1].subtract(p0).normalize();
        var total = tanL;
        var weightTotal = 1;
        last = Math.min(END_TANGENT_N_PTS, last - 1);
        for (var i = 2; i <= last; i++) {
            var ti = 1 - arclen[i] / totalLen;
            var weight = ti * ti * ti;
            var v = pts[i].subtract(p0).normalize();
            total = total.add(v.multiply(weight));
            weightTotal += weight;
        }
        if (total.length() > Number.EPSILON) {
            tanL = total.divide(weightTotal).normalize();
        }
        return tanL;
    };
    CurveFitBase.prototype.getRightTangent = function (first) {
        var pts = this._pts;
        var arclen = this._arclen;
        var totalLen = arclen[arclen.length - 1];
        var p3 = pts[pts.length - 1];
        var tanR = pts[pts.length - 2].subtract(p3).normalize();
        var total = tanR;
        var weightTotal = 1;
        first = Math.max(pts.length - (END_TANGENT_N_PTS + 1), first + 1);
        for (var i = pts.length - 3; i >= first; i--) {
            var t = arclen[i] / totalLen;
            var weight = t * t * t;
            var v = pts[i].subtract(p3).normalize();
            total = total.add(v.multiply(weight));
            weightTotal += weight;
        }
        if (total.length() > Number.EPSILON) {
            tanR = total.divide(weightTotal).normalize();
        }
        return tanR;
    };
    CurveFitBase.prototype.getCenterTangent = function (first, last, split) {
        var pts = this._pts;
        var arclen = this._arclen;
        var splitLen = arclen[split];
        var pSplit = pts[split];
        var firstLen = arclen[first];
        var partLen = splitLen - firstLen;
        var total = new vector_1.Vector(0, 0);
        var weightTotal = 0;
        for (var i = Math.max(first, split - MID_TANGENT_N_PTS); i < split; i++) {
            var t = (arclen[i] - firstLen) / partLen;
            var weight = t * t * t;
            var v = pts[i].subtract(pSplit).normalize();
            total = total.add(v.multiply(weight));
            weightTotal += weight;
        }
        var tanL = total.length() > Number.EPSILON && weightTotal > Number.EPSILON
            ? total.divide(weightTotal).normalize()
            : pts[split - 1].subtract(pSplit).normalize();
        partLen = arclen[last] - splitLen;
        var rMax = Math.min(last, split + MID_TANGENT_N_PTS);
        total = new vector_1.Vector(0, 0);
        weightTotal = 0;
        for (var i = split + 1; i <= rMax; i++) {
            var ti = 1 - (arclen[i] - splitLen) / partLen;
            var weight = ti * ti * ti;
            var v = pSplit.subtract(pts[i]).normalize();
            total = total.add(v.multiply(weight));
            weightTotal += weight;
        }
        var tanR = total.length() > Number.EPSILON && weightTotal > Number.EPSILON
            ? total.divide(weightTotal).normalize()
            : pSplit.subtract(pts[split + 1]).normalize();
        total = tanL.add(tanR);
        if (total.lengthSquared() < Number.EPSILON) {
            tanL = pts[split - 1].subtract(pSplit).normalize();
            tanR = pSplit.subtract(pts[split + 1]).normalize();
            total = tanL.add(tanR);
            return total.lengthSquared() < Number.EPSILON
                ? tanL
                : total.divide(2).normalize();
        }
        else {
            return total.divide(2).normalize();
        }
    };
    return CurveFitBase;
}());
exports.CurveFitBase = CurveFitBase;


/***/ }),

/***/ "./src/curves/curve-fit.ts":
/*!*********************************!*\
  !*** ./src/curves/curve-fit.ts ***!
  \*********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CurveFit = exports.generateArcLengths = exports.fit = void 0;
var curve_fit_base_1 = __webpack_require__(/*! ./curve-fit-base */ "./src/curves/curve-fit-base.ts");
var vector_1 = __webpack_require__(/*! ./vector */ "./src/curves/vector.ts");
// Copyright (c) 2015 burningmime
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//    claim that you wrote the original software. If you use this software
//    in a product, an acknowledgement in the product documentation would be
//    appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//    misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.
var END_TANGENT_N_PTS = 8;
var NO_CURVES = [];
function fit(points) {
    var arcLen = generateArcLengths(points);
    return [];
}
exports.fit = fit;
function generateArcLengths(points) {
    var results = [];
    results.push(0);
    var clen = 0;
    var pp = points[0];
    for (var i = 1; i < points.length; i++) {
        var np = points[i];
        clen += vector_1.Vector.from(pp).distance(vector_1.Vector.from(np));
        results.push(clen);
        pp = np;
    }
    return results;
}
exports.generateArcLengths = generateArcLengths;
var CurveFit = /** @class */ (function (_super) {
    __extends(CurveFit, _super);
    function CurveFit(_pts) {
        var _this = _super.call(this) || this;
        _this._pts = _pts;
        _this._result = [];
        var arclen = [];
        arclen.push(0);
        var clen = 0;
        var pp = _this._pts[0];
        for (var i = 1; i < _this._pts.length; i++) {
            var np = _this._pts[i];
            clen += vector_1.Vector.from(pp).distance(vector_1.Vector.from(np));
            arclen.push(clen);
            pp = np;
        }
        _this._arclen = arclen;
        return _this;
    }
    CurveFit.prototype.fit = function (maxError) {
        if (maxError < Number.EPSILON) {
            throw new Error('maxError cannot be negative/zero/less than epsilon value');
        }
        if (!this._pts) {
            throw new Error('points');
        }
        if (this._pts.length < 2) {
            return NO_CURVES;
        }
        this._squaredError = maxError * maxError;
        var last = this._pts.length - 1;
        var tanL = this.getLeftTangent(last);
        var tanR = this.getRightTangent(0);
        this.fitRecursive(0, last, tanL, tanR);
        return this._result;
    };
    CurveFit.prototype.fitRecursive = function (first, last, tanL, tanR) {
        if (first === void 0) { first = 0; }
        if (last === void 0) { last = 0; }
        var split = 0;
        var curve = null;
        var fitCurveResult = this.fitCurve(first, last, tanL, tanR, curve, split);
        split = fitCurveResult.split;
        curve = fitCurveResult.curve;
        if (fitCurveResult.response) {
            this._result.push(curve);
        }
        else {
            var tanM1 = this.getCenterTangent(first, last, split);
            var tanM2 = new vector_1.Vector(-tanM1.x, -tanM1.y);
            if (first == 0 && split < END_TANGENT_N_PTS) {
                tanL = this.getLeftTangent(split);
            }
            if (last == this._pts.length - 1 &&
                split > this._pts.length - (END_TANGENT_N_PTS + 1)) {
                tanR = this.getRightTangent(split);
            }
            // do actual recursion
            this.fitRecursive(first, split, tanL, tanM1);
            this.fitRecursive(split, last, tanM2, tanR);
        }
    };
    return CurveFit;
}(curve_fit_base_1.CurveFitBase));
exports.CurveFit = CurveFit;


/***/ }),

/***/ "./src/curves/curve-preprocess.ts":
/*!****************************************!*\
  !*** ./src/curves/curve-preprocess.ts ***!
  \****************************************/
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.removeDuplicates = exports.linearize = void 0;
// Copyright (c) 2015 burningmime
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//    claim that you wrote the original software. If you use this software
//    in a product, an acknowledgement in the product documentation would be
//    appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//    misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.
function linearize(src, minDistance, alwaysKeepLastVertex, alwaysLinearizeAllVertexes) {
    if (alwaysKeepLastVertex === void 0) { alwaysKeepLastVertex = false; }
    if (alwaysLinearizeAllVertexes === void 0) { alwaysLinearizeAllVertexes = true; }
    var dist = [];
    if (src === null) {
        throw new Error('Source vector array is null');
    }
    if (minDistance <= Number.EPSILON) {
        throw new Error("md " + minDistance + "' is be less than epsilon " + Number.EPSILON);
    }
    if (src.length > 0) {
        var pp = src[0];
        dist.push(pp);
        var cd = 0;
        for (var ip = 1; ip < src.length; ip++) {
            var p0 = src[ip - 1];
            var p1 = src[ip];
            var td = p0.distance(p1);
            if (cd + td > minDistance) {
                var pd = minDistance - cd;
                dist.push(p0.lerp(p1, pd / td));
                var rd = td - pd;
                while (rd > minDistance) {
                    rd -= minDistance;
                    if (alwaysLinearizeAllVertexes) {
                        var np = p0.lerp(p1, (td - rd) / td);
                        if (!np.equalsOrClose(pp)) {
                            dist.push(np);
                            pp = np;
                        }
                    }
                }
                cd = rd;
            }
            else {
                cd += td;
            }
        }
        var lp = src[src.length - 1];
        if (alwaysKeepLastVertex || !pp.equalsOrClose(lp)) {
            dist.push(lp);
        }
    }
    return dist;
}
exports.linearize = linearize;
function removeDuplicates(pts) {
    if (pts.length < 2) {
        return pts;
    }
    var prev = pts[0];
    var len = pts.length;
    var nDup = 0;
    for (var i = 1; i < len; i++) {
        var cur = pts[i];
        if (prev.equalsOrClose(cur))
            nDup++;
        else
            prev = cur;
    }
    if (nDup == 0) {
        return pts;
    }
    else {
        var dst = [];
        prev = pts[0];
        dst.push(prev);
        for (var i = 1; i < len; i++) {
            var cur = pts[i];
            if (!prev.equalsOrClose(cur)) {
                dst.push(cur);
                prev = cur;
            }
        }
        return dst;
    }
}
exports.removeDuplicates = removeDuplicates;


/***/ }),

/***/ "./src/curves/main.ts":
/*!****************************!*\
  !*** ./src/curves/main.ts ***!
  \****************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./cubic-bezier */ "./src/curves/cubic-bezier.ts"), exports);
__exportStar(__webpack_require__(/*! ./curve-fit-base */ "./src/curves/curve-fit-base.ts"), exports);
__exportStar(__webpack_require__(/*! ./curve-fit */ "./src/curves/curve-fit.ts"), exports);
__exportStar(__webpack_require__(/*! ./curve-preprocess */ "./src/curves/curve-preprocess.ts"), exports);
__exportStar(__webpack_require__(/*! ./vector */ "./src/curves/vector.ts"), exports);


/***/ }),

/***/ "./src/curves/vector.ts":
/*!******************************!*\
  !*** ./src/curves/vector.ts ***!
  \******************************/
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Vector = void 0;
var Vector = /** @class */ (function () {
    function Vector(x, y) {
        this.x = x;
        this.y = y;
    }
    Vector.from = function (point) {
        return new Vector(point.x, point.y);
    };
    Vector.prototype.add = function (a) {
        return new Vector(this.x + (a instanceof Vector ? a.x : a), this.y + (a instanceof Vector ? a.y : a));
    };
    Vector.prototype.subtract = function (a) {
        return new Vector(this.x - (a instanceof Vector ? a.x : a), this.y - (a instanceof Vector ? a.y : a));
    };
    Vector.prototype.multiply = function (a) {
        return new Vector(this.x * (a instanceof Vector ? a.x : a), this.y * (a instanceof Vector ? a.y : a));
    };
    Vector.prototype.divide = function (a) {
        return new Vector(this.x / (a instanceof Vector ? a.x : a), this.y / (a instanceof Vector ? a.y : a));
    };
    Vector.prototype.distance = function (a) {
        return Math.sqrt(this.distanceSquared(a));
    };
    Vector.prototype.distanceSquared = function (a) {
        var x = this.x - a.x;
        var y = this.y - a.y;
        return x * x + y * y;
    };
    Vector.prototype.lerp = function (v, fraction) {
        return new Vector(this.x + (v.x - this.x) * fraction, this.y + (v.y - this.y) * fraction);
    };
    Vector.prototype.equalsOrClose = function (a) {
        return this.distanceSquared(a) < Number.EPSILON;
    };
    Vector.prototype.dot = function (a) {
        return this.x * a.x + this.y * a.y;
    };
    Vector.prototype.lengthSquared = function () {
        return this.x * this.x + this.y * this.y;
    };
    Vector.prototype.length = function () {
        return Math.sqrt(this.x * this.x + this.y * this.y);
    };
    Vector.prototype.normalize = function () {
        return this.divide(this.length());
    };
    return Vector;
}());
exports.Vector = Vector;


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/curves/main.ts");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=curves.min.js.map