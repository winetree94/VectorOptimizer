(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["Curves"] = factory();
	else
		root["Curves"] = factory();
})(self, function() {
return /******/ (function() { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/curves.sample/drawer.ts":
/*!*************************************!*\
  !*** ./src/curves.sample/drawer.ts ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Drawer = exports.PreprocessMode = exports.RenderMode = void 0;
/* eslint-disable no-case-declarations */
var curve_fit_1 = __webpack_require__(/*! ../curves/curve-fit */ "./src/curves/curve-fit.ts");
var curve_preprocess_1 = __webpack_require__(/*! ../curves/curve-preprocess */ "./src/curves/curve-preprocess.ts");
var vector_1 = __webpack_require__(/*! ../curves/vector */ "./src/curves/vector.ts");
function getRandomColor() {
    var letters = '0123456789ABCDEF';
    var color = '#';
    for (var i = 0; i < 6; i++) {
        color += letters[Math.floor(Math.random() * 16)];
    }
    return color;
}
var RenderMode;
(function (RenderMode) {
    RenderMode["ORIGINAL_POINT"] = "original-points";
    RenderMode["PREPROCESSED"] = "preprocessed";
    RenderMode["CONTROL_POINTS"] = "control-points";
    RenderMode["REPARAMATERIZED"] = "reparamaterized";
    RenderMode["FINAL_CURVES"] = "final-curves";
})(RenderMode = exports.RenderMode || (exports.RenderMode = {}));
var PreprocessMode;
(function (PreprocessMode) {
    PreprocessMode["NONE"] = "none";
    PreprocessMode["LINEARIZE"] = "linearize";
    PreprocessMode["RAMER_DOUGLAS_PEUCHER"] = "ramer-douglas-peucher";
})(PreprocessMode = exports.PreprocessMode || (exports.PreprocessMode = {}));
var Drawer = /** @class */ (function () {
    function Drawer(element) {
        this.element = element;
        this.originPoints = [];
        this._options = {
            preprocessMode: PreprocessMode.NONE,
            renderMode: RenderMode.ORIGINAL_POINT,
            linearizePointDistance: 8,
            curveFittingError: 8,
            colorize: true,
        };
        element.addEventListener('pointerdown', this.onMouseDown.bind(this));
        element.addEventListener('mousedown', this.onMouseDown.bind(this));
        element.addEventListener('touchstart', function (e) { return e.preventDefault(); });
    }
    Object.defineProperty(Drawer.prototype, "options", {
        get: function () {
            return this._options;
        },
        set: function (options) {
            this._options = __assign(__assign({}, this._options), options);
            this.render();
        },
        enumerable: false,
        configurable: true
    });
    Drawer.prototype.onMouseDown = function (event) {
        var _this = this;
        event.preventDefault();
        this.clearOriginPoints();
        this.clearView();
        var startPoint = {
            x: event.offsetX,
            y: event.offsetY,
        };
        var $startCircle = this.createCircle(startPoint);
        this.element.appendChild($startCircle);
        this.originPoints.push(startPoint);
        var onMouseMove = function (event) {
            var point = {
                x: event.offsetX,
                y: event.offsetY,
            };
            var $circle = _this.createCircle(point);
            _this.element.appendChild($circle);
            _this.originPoints.push(point);
        };
        var onMouseUp = function () {
            _this.element.removeEventListener('pointermove', onMouseMove);
            _this.element.removeEventListener('pointerup', onMouseUp);
            _this.element.removeEventListener('mousemove', onMouseMove);
            _this.element.removeEventListener('mouseup', onMouseUp);
            _this.render();
        };
        this.element.addEventListener('mousemove', onMouseMove);
        this.element.addEventListener('mouseup', onMouseUp);
        this.element.addEventListener('pointermove', onMouseMove);
        this.element.addEventListener('pointerup', onMouseUp);
    };
    Drawer.prototype.createCircle = function (point) {
        var $circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        $circle.setAttribute('cx', point.x.toString());
        $circle.setAttribute('cy', point.y.toString());
        $circle.setAttribute('r', (1).toString());
        $circle.setAttribute('fill', 'red');
        return $circle;
    };
    Drawer.prototype.clearOriginPoints = function () {
        this.originPoints.splice(0);
    };
    Drawer.prototype.clearView = function () {
        this.element.innerHTML = '';
    };
    Drawer.prototype.transformToVector = function () {
        return this.originPoints.map(function (point) { return vector_1.Vector.from(point); });
    };
    Drawer.prototype.getPreprocessedVectors = function () {
        switch (this.options.preprocessMode) {
            case PreprocessMode.NONE:
                return this.transformToVector();
            case PreprocessMode.LINEARIZE:
                return curve_preprocess_1.linearize(this.transformToVector(), this.options.linearizePointDistance);
            case PreprocessMode.RAMER_DOUGLAS_PEUCHER:
                return this.transformToVector();
        }
    };
    Drawer.prototype.render = function () {
        var _this = this;
        switch (this.options.renderMode) {
            case RenderMode.ORIGINAL_POINT:
                this.clearView();
                this.originPoints.forEach(function (point) {
                    var $circle = _this.createCircle(point);
                    _this.element.appendChild($circle);
                });
                break;
            case RenderMode.PREPROCESSED:
                this.clearView();
                this.getPreprocessedVectors().forEach(function (vector) {
                    var $circle = _this.createCircle(vector);
                    _this.element.appendChild($circle);
                });
                break;
            case RenderMode.FINAL_CURVES:
                this.clearView();
                var $path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                $path.setAttribute('fill', 'none');
                $path.setAttribute('stroke', 'red');
                var curveFit = new curve_fit_1.CurveFit(this.getPreprocessedVectors()
                // ExpectedLinearizedSample.map((point) => Vector.from(point))
                );
                curveFit.Fit(this.options.curveFittingError).forEach(function (bezier) {
                    var $path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    $path.setAttribute('fill', 'none');
                    $path.setAttribute('stroke', _this.options.colorize ? getRandomColor() : 'red');
                    $path.setAttribute('stroke-width', 2 + "px");
                    $path.setAttribute('d', "M " + bezier.p0.x + " " + bezier.p0.y + " C " + bezier.p1.x + " " + bezier.p1.y + " " + bezier.p2.x + " " + bezier.p2.y + " " + bezier.p3.x + " " + bezier.p3.y);
                    _this.element.appendChild($path);
                });
                break;
        }
    };
    return Drawer;
}());
exports.Drawer = Drawer;


/***/ }),

/***/ "./src/curves/cubic-bezier.ts":
/*!************************************!*\
  !*** ./src/curves/cubic-bezier.ts ***!
  \************************************/
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CubicBezier = void 0;
var CubicBezier = /** @class */ (function () {
    function CubicBezier(p0, p1, p2, p3) {
        this.p0 = p0;
        this.p1 = p1;
        this.p2 = p2;
        this.p3 = p3;
    }
    CubicBezier.prototype.sample = function (t) {
        var ti = 1 - t;
        var t0 = ti * ti * ti;
        var t1 = 3 * ti * ti * t;
        var t2 = 3 * ti * t * t;
        var t3 = t * t * t;
        return this.p0
            .multiply(t0)
            .add(this.p1.multiply(t1))
            .add(this.p2.multiply(t2))
            .add(this.p3.multiply(t3));
    };
    return CubicBezier;
}());
exports.CubicBezier = CubicBezier;


/***/ }),

/***/ "./src/curves/curve-fit-base.ts":
/*!**************************************!*\
  !*** ./src/curves/curve-fit-base.ts ***!
  \**************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CurveFitBase = void 0;
var cubic_bezier_1 = __webpack_require__(/*! ./cubic-bezier */ "./src/curves/cubic-bezier.ts");
var vector_1 = __webpack_require__(/*! ./vector */ "./src/curves/vector.ts");
// Copyright (c) 2015 burningmime
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//    claim that you wrote the original software. If you use this software
//    in a product, an acknowledgement in the product documentation would be
//    appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//    misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.
var MAX_ITERS = 4; // maximum number of iterations of newton's method to run before giving up and splitting curve
var END_TANGENT_N_PTS = 8; // maximum number of points to base end tangent on
var MID_TANGENT_N_PTS = 4; // maximum number of points on each side to base mid tangent on
// This is the base class containing implementations common to CurveFit and CurveBuilder.
// Most of this is ported from http://tog.acm.org/resources/GraphicsGems/gems/FitCurves.c
var CurveFitBase = /** @class */ (function () {
    function CurveFitBase() {
        // current parametrization of the curve. When fitting, u[i] is the parametrization for the point in pts[first + i]. This is
        // an optimization for CurveBuilder, since it might not need to allocate as big of a _u as is necessary to hold the whole curve.
        this._u = [];
        // maximum squared error before we split the curve
        this._squaredError = 0;
    }
    /// <summary>
    /// Tries to fit single Bezier curve to the points in [first ... last]. Destroys anything in <see cref="_u"/> in the process.
    /// Assumes there are at least two points to fit.
    /// </summary>
    /// <param name="first">Index of first point to consider.</param>
    /// <param name="last">Index of last point to consider (inclusive).</param>
    /// <param name="tanL">Tangent at teh start of the curve ("left").</param>
    /// <param name="tanR">Tangent on the end of the curve ("right").</param>
    /// <param name="curve">The fitted curve.</param>
    /// <param name="split">Point at which to split if this method returns false.</param>
    /// <returns>true if the fit was within error tolerence, false if the curve should be split. Even if this returns false, curve will contain
    /// a curve that somewhat fits the points; it's just outside error tolerance.</returns>
    CurveFitBase.prototype.FitCurve = function (first, last, tanL, tanR, curve, split) {
        var result = {
            response: false,
            split: split,
            curve: curve,
        };
        var pts = this._pts;
        var nPts = last - first + 1;
        if (nPts < 2) {
            throw new Error('INTERNAL ERROR: Should always have at least 2 points here');
        }
        else if (nPts == 2) {
            // if we only have 2 points left, estimate the curve using Wu/Barsky
            var p0 = pts[first];
            var p3 = pts[last];
            var alpha = p0.distance(p3) / 3;
            var p1 = tanL.multiply(alpha).add(p0);
            var p2 = tanR.multiply(alpha).add(p3);
            curve = new cubic_bezier_1.CubicBezier(p0, p1, p2, p3);
            result.curve = curve;
            split = 0;
            result.split = split;
            result.response = true;
            return result;
        }
        else {
            split = 0;
            result.split = split;
            this.arcLengthParamaterize(first, last); // initially start u with a simple chord-length paramaterization
            curve = null;
            result.curve = curve;
            for (var i = 0; i < MAX_ITERS + 1; i++) {
                // use newton's method to find better parameters (except on first run, since we don't have a curve yet)
                if (i != 0) {
                    this.Reparameterize(first, last, curve);
                }
                // generate the curve itself
                curve = this.GenerateBezier(first, last, tanL, tanR);
                result.curve = curve;
                // calculate error and get split point (point of max error)
                var res = this.FindMaxSquaredError(first, last, curve, result.split);
                result.split = res.split;
                // if we're within error tolerance, awesome!
                if (res.response < this._squaredError) {
                    result.response = true;
                    return result;
                }
            }
            result.response = false;
            return result;
        }
    };
    CurveFitBase.prototype.FindMaxSquaredError = function (first, last, curve, split) {
        if (curve === void 0) { curve = null; }
        if (split === void 0) { split = 0; }
        var result = {
            response: 0,
            split: split,
        };
        var pts = this._pts;
        var u = this._u;
        var s = (last - first + 1) / 2;
        var nPts = last - first + 1;
        var max = 0;
        for (var i = 1; i < nPts; i++) {
            var v0 = pts[first + i];
            var v1 = curve.sample(u[i]);
            var d = v0.distanceSquared(v1);
            if (d > max) {
                max = d;
                s = i;
            }
        }
        // split at point of maximum error
        split = s + first;
        if (split <= first)
            split = first + 1;
        if (split >= last)
            split = last - 1;
        result.split = split;
        result.response = max;
        return result;
    };
    CurveFitBase.prototype.GenerateBezier = function (first, last, tanL, tanR) {
        var pts = this._pts;
        var u = this._u;
        var nPts = last - first + 1;
        var p0 = pts[first];
        var p3 = pts[last]; // first and last points of curve are actual points on data
        var c00 = 0, c01 = 0, c11 = 0, x0 = 0, x1 = 0; // matrix members -- both C[0,1] and C[1,0] are the same, stored in c01
        for (var i = 1; i < nPts; i++) {
            // Calculate cubic bezier multipliers
            var t = u[i];
            var ti = 1 - t;
            var t0 = ti * ti * ti;
            var t1 = 3 * ti * ti * t;
            var t2 = 3 * ti * t * t;
            var t3 = t * t * t;
            // For X matrix; moving this up here since profiling shows it's better up here (maybe a0/a1 not in registers vs only v not in regs)
            var s = p0
                .multiply(t0)
                .add(p0.multiply(t1))
                .add(p3.multiply(t2))
                .add(p3.multiply(t3)); // NOTE: this would be Q(t) if p1=p0 and p2=p3
            var v = pts[first + i].subtract(s);
            // C matrix
            var a0 = tanL.multiply(t1);
            var a1 = tanR.multiply(t2);
            c00 += a0.dot(a0);
            c01 += a0.dot(a1);
            c11 += a1.dot(a1);
            // X matrix
            x0 += a0.dot(v);
            x1 += a1.dot(v);
        }
        // determinents of X and C matrices
        var det_C0_C1 = c00 * c11 - c01 * c01;
        var det_C0_X = c00 * x1 - c01 * x0;
        var det_X_C1 = x0 * c11 - x1 * c01;
        var alphaL = det_X_C1 / det_C0_C1;
        var alphaR = det_C0_X / det_C0_C1;
        // if alpha is negative, zero, or very small (or we can't trust it since C matrix is small), fall back to Wu/Barsky heuristic
        var linDist = p0.distance(p3);
        var epsilon2 = Number.EPSILON * linDist;
        if (Math.abs(det_C0_C1) < Number.EPSILON ||
            alphaL < epsilon2 ||
            alphaR < epsilon2) {
            var alpha = linDist / 3;
            var p1 = tanL.multiply(alpha).add(p0);
            var p2 = tanR.multiply(alpha).add(p3);
            return new cubic_bezier_1.CubicBezier(p0, p1, p2, p3);
        }
        else {
            var p1 = tanL.multiply(alphaL).add(p0);
            var p2 = tanR.multiply(alphaR).add(p3);
            return new cubic_bezier_1.CubicBezier(p0, p1, p2, p3);
        }
    };
    /// <summary>
    /// Attempts to find a slightly better parameterization for u on the given curve.
    /// </summary>
    CurveFitBase.prototype.Reparameterize = function (first, last, curve) {
        var pts = this._pts;
        var u = this._u;
        var nPts = last - first;
        for (var i = 1; i < nPts; i++) {
            var p = pts[first + i];
            var t = u[i];
            var ti = 1 - t;
            // Control vertices for Q'
            var qp0 = curve.p1.subtract(curve.p0).multiply(3);
            var qp1 = curve.p2.subtract(curve.p1).multiply(3);
            var qp2 = curve.p3.subtract(curve.p2).multiply(3);
            // Control vertices for Q''
            var qpp0 = qp1.subtract(qp0).multiply(2);
            var qpp1 = qp2.subtract(qp1).multiply(2);
            // Evaluate Q(t), Q'(t), and Q''(t)
            var p0 = curve.sample(t);
            var p1 = qp0
                .multiply(ti * ti)
                .add(qp1.multiply(2 * ti * t))
                .add(qp2.multiply(t * t));
            var p2 = qpp0.multiply(ti).add(qpp1.multiply(t));
            // these are the actual fitting calculations using http://en.wikipedia.org/wiki/Newton%27s_method
            // We can't just use .X and .Y because Unity uses lower-case "x" and "y".
            var num = (p0.x - p.x) * p1.x + (p0.y - p.y) * p1.y;
            var den = p1.x * p1.x + p1.y * p1.y + (p0.x - p.x) * p2.x + (p0.y - p.y) * p2.y;
            var newU = t - num / den;
            if (Math.abs(den) > Number.EPSILON && newU >= 0 && newU <= 1) {
                u[i] = newU;
            }
        }
    };
    CurveFitBase.prototype.arcLengthParamaterize = function (first, last) {
        var arclen = this._arclen;
        var u = this._u;
        u.splice(0);
        var diff = arclen[last] - arclen[first];
        var start = arclen[first];
        var nPts = last - first;
        u.push(0);
        for (var i = 1; i < nPts; i++) {
            u.push((arclen[first + i] - start) / diff);
        }
        u.push(1);
    };
    CurveFitBase.prototype.getLeftTangent = function (last) {
        var pts = this._pts;
        var arclen = this._arclen;
        var totalLen = arclen[arclen.length - 1];
        var p0 = pts[0];
        var tanL = pts[1].subtract(p0).normalize();
        var total = tanL;
        var weightTotal = 1;
        last = Math.min(END_TANGENT_N_PTS, last - 1);
        for (var i = 2; i <= last; i++) {
            var ti = 1 - arclen[i] / totalLen;
            var weight = ti * ti * ti;
            var v = pts[i].subtract(p0).normalize();
            total = total.add(v.multiply(weight));
            weightTotal += weight;
        }
        // if the vectors add up to zero (ie going opposite directions), there's no way to normalize them
        if (total.length() > Number.EPSILON) {
            tanL = total.divide(weightTotal).normalize();
        }
        return tanL;
    };
    CurveFitBase.prototype.getRightTangent = function (first) {
        var pts = this._pts;
        var arclen = this._arclen;
        var totalLen = arclen[arclen.length - 1];
        var p3 = pts[pts.length - 1];
        var tanR = pts[pts.length - 2].subtract(p3).normalize();
        var total = tanR;
        var weightTotal = 1;
        first = Math.max(pts.length - (END_TANGENT_N_PTS + 1), first + 1);
        for (var i = pts.length - 3; i >= first; i--) {
            var t = arclen[i] / totalLen;
            var weight = t * t * t;
            var v = pts[i].subtract(p3).normalize();
            total = total.add(v.multiply(weight));
            weightTotal += weight;
        }
        if (total.length() > Number.EPSILON) {
            tanR = total.divide(weightTotal).normalize();
        }
        return tanR;
    };
    /// <summary>
    /// Gets the tangent at a given point in the curve.
    /// </summary>
    CurveFitBase.prototype.GetCenterTangent = function (first, last, split) {
        var pts = this._pts;
        var arclen = this._arclen;
        // because we want to maintain C1 continuity on the spline, the tangents on either side must be inverses of one another
        // Debug.Assert(first < split && split < last);
        var splitLen = arclen[split];
        var pSplit = pts[split];
        // left side
        var firstLen = arclen[first];
        var partLen = splitLen - firstLen;
        var total = new vector_1.Vector(0, 0);
        var weightTotal = 0;
        for (var i = Math.max(first, split - MID_TANGENT_N_PTS); i < split; i++) {
            var t = (arclen[i] - firstLen) / partLen;
            var weight = t * t * t;
            var v = pts[i].subtract(pSplit).normalize();
            total = total.add(v.multiply(weight));
            weightTotal += weight;
        }
        var tanL = total.length() > Number.EPSILON && weightTotal > Number.EPSILON
            ? total.divide(weightTotal).normalize()
            : pts[split - 1].subtract(pSplit).normalize();
        // right side
        partLen = arclen[last] - splitLen;
        var rMax = Math.min(last, split + MID_TANGENT_N_PTS);
        total = new vector_1.Vector(0, 0);
        weightTotal = 0;
        for (var i = split + 1; i <= rMax; i++) {
            var ti = 1 - (arclen[i] - splitLen) / partLen;
            var weight = ti * ti * ti;
            var v = pSplit.subtract(pts[i]).normalize();
            total = total.add(v.multiply(weight));
            weightTotal += weight;
        }
        var tanR = total.length() > Number.EPSILON && weightTotal > Number.EPSILON
            ? total.divide(weightTotal).normalize()
            : pSplit.subtract(pts[split + 1]).normalize();
        // The reason we separate this into two halves is because we want the right and left tangents to be weighted
        // equally no matter the weights of the individual parts of them, so that one of the curves doesn't get screwed
        // for the pleasure of the other half
        total = tanL.add(tanR);
        // Since the points are never coincident, the vector between any two of them will be normalizable, however this can happen in some really
        // odd cases when the points are going directly opposite directions (therefore the tangent is undefined)
        if (total.lengthSquared() < Number.EPSILON) {
            // try one last time using only the three points at the center, otherwise just use one of the sides
            tanL = pts[split - 1].subtract(pSplit).normalize();
            tanR = pSplit.subtract(pts[split + 1]).normalize();
            total = tanL.add(tanR);
            return total.lengthSquared() < Number.EPSILON
                ? tanL
                : total.divide(2).normalize();
        }
        else {
            return total.divide(2).normalize();
        }
    };
    return CurveFitBase;
}());
exports.CurveFitBase = CurveFitBase;


/***/ }),

/***/ "./src/curves/curve-fit.ts":
/*!*********************************!*\
  !*** ./src/curves/curve-fit.ts ***!
  \*********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CurveFit = void 0;
var curve_fit_base_1 = __webpack_require__(/*! ./curve-fit-base */ "./src/curves/curve-fit-base.ts");
var vector_1 = __webpack_require__(/*! ./vector */ "./src/curves/vector.ts");
var END_TANGENT_N_PTS = 8;
var NO_CURVES = [];
var CurveFit = /** @class */ (function (_super) {
    __extends(CurveFit, _super);
    function CurveFit(_pts) {
        var _this = _super.call(this) || this;
        _this._pts = _pts;
        _this._result = [];
        var arclen = [];
        arclen.push(0);
        var clen = 0;
        var pp = _this._pts[0];
        for (var i = 1; i < _this._pts.length; i++) {
            var np = _this._pts[i];
            clen += vector_1.Vector.from(pp).distance(vector_1.Vector.from(np));
            arclen.push(clen);
            pp = np;
        }
        _this._arclen = arclen;
        return _this;
    }
    CurveFit.prototype.Fit = function (maxError) {
        if (maxError < Number.EPSILON) {
            throw new Error('maxError cannot be negative/zero/less than epsilon value');
        }
        // null / undefined safety
        if (!this._pts) {
            throw new Error('points');
        }
        // need at least 2 points to do anything
        if (this._pts.length < 2) {
            return NO_CURVES;
        }
        // initialize arrays
        this._squaredError = maxError * maxError;
        // Find tangents at ends
        var last = this._pts.length - 1;
        var tanL = this.getLeftTangent(last);
        var tanR = this.getRightTangent(0);
        // do the actual fit
        this.FitRecursive(0, last, tanL, tanR);
        return this._result;
    };
    CurveFit.prototype.FitRecursive = function (first, last, tanL, tanR) {
        if (first === void 0) { first = 0; }
        if (last === void 0) { last = 0; }
        var split = 0;
        var curve = null;
        var fitCurveResult = this.FitCurve(first, last, tanL, tanR, curve, split);
        split = fitCurveResult.split;
        curve = fitCurveResult.curve;
        if (fitCurveResult.response) {
            this._result.push(curve);
        }
        else {
            // If we get here, fitting failed, so we need to recurse
            // first, get mid tangent
            var tanM1 = this.GetCenterTangent(first, last, split);
            var tanM2 = new vector_1.Vector(-tanM1.x, -tanM1.y);
            // our end tangents might be based on points outside the new curve (this is possible for mid tangents too
            // but since we need to maintain C1 continuity, it's too late to do anything about it)
            if (first == 0 && split < END_TANGENT_N_PTS) {
                tanL = this.getLeftTangent(split);
            }
            if (last == this._pts.length - 1 &&
                split > this._pts.length - (END_TANGENT_N_PTS + 1)) {
                tanR = this.getRightTangent(split);
            }
            // do actual recursion
            this.FitRecursive(first, split, tanL, tanM1);
            this.FitRecursive(split, last, tanM2, tanR);
        }
    };
    return CurveFit;
}(curve_fit_base_1.CurveFitBase));
exports.CurveFit = CurveFit;


/***/ }),

/***/ "./src/curves/curve-preprocess.ts":
/*!****************************************!*\
  !*** ./src/curves/curve-preprocess.ts ***!
  \****************************************/
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PerpendicularDistance = exports.RdpReduce = exports.RemoveDuplicates = exports.linearize = void 0;
/**
 * Creates a list of equally spaced points that lie on the path described by straight line segments between
 * adjacent points in the source list.
 *
 * @param src - Source list of points.
 * @param md - Distance between points on the new path.
 * @param keepLast - Always keep last points, default is false.
 * @param all - defualt is true.
 * @returns List of equally-spaced points on the path.
 */
function linearize(src, md, keepLast, all) {
    if (keepLast === void 0) { keepLast = false; }
    if (all === void 0) { all = true; }
    var dist = [];
    if (src === null) {
        throw new Error('src');
    }
    if (md <= Number.EPSILON) {
        throw new Error("md " + md + "' is be less than epislon " + Number.EPSILON);
    }
    if (src.length > 0) {
        var pp = src[0];
        dist.push(pp);
        var cd = 0;
        for (var ip = 1; ip < src.length; ip++) {
            var p0 = src[ip - 1];
            var p1 = src[ip];
            var td = p0.distance(p1);
            if (cd + td > md) {
                var pd = md - cd;
                dist.push(p0.lerp(p1, pd / td));
                var rd = td - pd;
                while (rd > md) {
                    rd -= md;
                    if (all) {
                        var np = p0.lerp(p1, (td - rd) / td);
                        if (!np.equalsOrClose(pp)) {
                            dist.push(np);
                            pp = np;
                        }
                    }
                }
                cd = rd;
            }
            else {
                cd += td;
            }
        }
        var lp = src[src.length - 1];
        if (keepLast || !pp.equalsOrClose(lp)) {
            dist.push(lp);
        }
    }
    return dist;
}
exports.linearize = linearize;
/**
 * Removes any repeated points (that is, one point extremely close to the previous one). The same point can
 * appear multiple times just not right after one another. This does not modify the input list. If no repeats
 * were found, it returns the input list; otherwise it creates a new list with the repeats removed.
 *
 * @param pts - Initial list of points
 * @returns Either pts (if no duplicates were found), or a new list containing pts with duplicates removed.
 */
function RemoveDuplicates(pts) {
    if (pts.length < 2) {
        return pts;
    }
    // Common case -- no duplicates, so just return the source list
    var prev = pts[0];
    var len = pts.length;
    var nDup = 0;
    for (var i = 1; i < len; i++) {
        var cur = pts[i];
        if (prev.equalsOrClose(cur))
            nDup++;
        else
            prev = cur;
    }
    if (nDup == 0) {
        return pts;
    }
    else {
        // Create a copy without them
        var dst = [];
        prev = pts[0];
        dst.push(prev);
        for (var i = 1; i < len; i++) {
            var cur = pts[i];
            if (!prev.equalsOrClose(cur)) {
                dst.push(cur);
                prev = cur;
            }
        }
        return dst;
    }
}
exports.RemoveDuplicates = RemoveDuplicates;
/// <summary>
/// "Reduces" a set of line segments by removing points that are too far away. Does not modify the input list; returns
/// a new list with the points removed.
/// The image says it better than I could ever describe: http://upload.wikimedia.org/wikipedia/commons/3/30/Douglas-Peucker_animated.gif
/// The wiki article: http://en.wikipedia.org/wiki/Ramer%E2%80%93Douglas%E2%80%93Peucker_algorithm
/// Based on:  http://www.codeproject.com/Articles/18936/A-Csharp-Implementation-of-Douglas-Peucker-Line-Ap
/// </summary>
/// <param name="pts">Points to reduce</param>
/// <param name="error">Maximum distance of a point to a line. Low values (~2-4) work well for mouse/touchscreen data.</param>
/// <returns>A new list containing only the points needed to approximate the curve.</returns>
// public static List<VECTOR> RdpReduce(List<VECTOR> pts, FLOAT error)
// {
//     if(pts == null) throw new ArgumentNullException("pts");
//     pts = RemoveDuplicates(pts);
//     if(pts.Count < 3)
//         return new List<VECTOR>(pts);
//     List<int> keepIndex = new List<int>(Math.Max(pts.Count / 2, 16));
//     keepIndex.Add(0);
//     keepIndex.Add(pts.Count - 1);
//     RdpRecursive(pts, error, 0, pts.Count - 1, keepIndex);
//     keepIndex.Sort();
//     List<VECTOR> res = new List<VECTOR>(keepIndex.Count);
//     // ReSharper disable once LoopCanBeConvertedToQuery
//     foreach(int idx in keepIndex)
//         res.Add(pts[idx]);
//     return res;
// }
function RdpReduce(pts, error) {
    // if(pts == null)  {
    //   throw new Error("pts");
    // }
    // pts = RemoveDuplicates(pts);
    // if(pts.length < 3) {
    //   return [...pts];
    // }
    // const keepIndex: number[] = [];
    // keepIndex.push(0);
    // keepIndex.push(pts.length - 1);
    // RdpRecursive(pts, error, 0, pts.Count - 1, keepIndex);
    // keepIndex.Sort();
    // List<VECTOR> res = new List<VECTOR>(keepIndex.Count);
    // // ReSharper disable once LoopCanBeConvertedToQuery
    // foreach(int idx in keepIndex)
    //     res.Add(pts[idx]);
    // return res;
    return [];
}
exports.RdpReduce = RdpReduce;
/// <summary>
/// Finds the shortest distance between a point and a line. See: http://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line
/// </summary>
/// <param name="a">First point of the line.</param>
/// <param name="b">Last point of the line.</param>
/// <param name="abDist">Distance between a and b (length of the line).</param>
/// <param name="aCrossB">"a.X*b.Y - b.X*a.Y" This would be the Z-component of (⟪a.X, a.Y, 0⟫ ⨯ ⟪b.X, b.Y, 0⟫) in 3-space.</param>
/// <param name="p">The point to test.</param>
/// <returns>The perpendicular distance to the line.</returns>
function PerpendicularDistance(a, b, abDist, aCrossB, p) {
    // a profile with the test data showed that originally this was eating up ~44% of the runtime. So, this went through
    // several iterations of optimization and staring at the disassembly. I tried different methods of using cross
    // products, doing the computation with larger vector types, etc... this is the best I could do in ~45 minutes
    // running on 3 hours of sleep, which is all scalar math, but RyuJIT puts it into XMM registers and does
    // ADDSS/SUBSS/MULSS/DIVSS because that's what it likes to do whenever it sees a vector in a function.
    var area = Math.abs(aCrossB + b.x * p.y + p.x * a.y - p.x * b.y - a.x * p.y);
    var height = area / abDist;
    return height;
}
exports.PerpendicularDistance = PerpendicularDistance;


/***/ }),

/***/ "./src/curves/vector.ts":
/*!******************************!*\
  !*** ./src/curves/vector.ts ***!
  \******************************/
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Vector = void 0;
var Vector = /** @class */ (function () {
    function Vector(x, y) {
        this.x = x;
        this.y = y;
    }
    Vector.from = function (point) {
        return new Vector(point.x, point.y);
    };
    Vector.prototype.add = function (a) {
        return new Vector(this.x + (a instanceof Vector ? a.x : a), this.y + (a instanceof Vector ? a.y : a));
    };
    Vector.prototype.subtract = function (a) {
        return new Vector(this.x - (a instanceof Vector ? a.x : a), this.y - (a instanceof Vector ? a.y : a));
    };
    Vector.prototype.multiply = function (a) {
        return new Vector(this.x * (a instanceof Vector ? a.x : a), this.y * (a instanceof Vector ? a.y : a));
    };
    Vector.prototype.divide = function (a) {
        return new Vector(this.x / (a instanceof Vector ? a.x : a), this.y / (a instanceof Vector ? a.y : a));
    };
    Vector.prototype.distance = function (a) {
        return Math.sqrt(this.distanceSquared(a));
    };
    Vector.prototype.distanceSquared = function (a) {
        var x = this.x - a.x;
        var y = this.y - a.y;
        return x * x + y * y;
    };
    Vector.prototype.lerp = function (v, fraction) {
        return new Vector(this.x + (v.x - this.x) * fraction, this.y + (v.y - this.y) * fraction);
    };
    Vector.prototype.equalsOrClose = function (a) {
        return this.distanceSquared(a) < Number.EPSILON;
    };
    Vector.prototype.dot = function (a) {
        return this.x * a.x + this.y * a.y;
    };
    Vector.prototype.lengthSquared = function () {
        return this.x * this.x + this.y * this.y;
    };
    Vector.prototype.length = function () {
        return Math.sqrt(this.x * this.x + this.y * this.y);
    };
    Vector.prototype.normalize = function () {
        return this.divide(this.length());
    };
    return Vector;
}());
exports.Vector = Vector;


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
!function() {
var exports = __webpack_exports__;
/*!***********************************!*\
  !*** ./src/curves.sample/main.ts ***!
  \***********************************/

Object.defineProperty(exports, "__esModule", ({ value: true }));
var drawer_1 = __webpack_require__(/*! ./drawer */ "./src/curves.sample/drawer.ts");
var $svg = document.getElementById('svg-root');
var preprocessMode = drawer_1.PreprocessMode.NONE;
var renderMode = drawer_1.RenderMode.ORIGINAL_POINT;
var colorize = true;
var linearizePointDistance = 8;
var ramerDouglaspeucherError = 1;
var curveFittingError = 8;
var $preprocessModes = document.getElementsByName('preprocess-mode');
$preprocessModes.forEach(function ($preprocessMode) {
    return $preprocessMode.addEventListener('click', function (e) {
        var target = e.target;
        if (target.checked) {
            preprocessMode = target.value;
            onValueChanged();
        }
    });
});
var $renderModes = document.getElementsByName('render-mode');
$renderModes.forEach(function ($renderMode) {
    return $renderMode.addEventListener('click', function (e) {
        var target = e.target;
        if (target.checked) {
            renderMode = target.value;
            onValueChanged();
        }
    });
});
var $colorize = document.getElementById('colorize');
$colorize.addEventListener('click', function (e) {
    colorize = !!$colorize.checked;
    onValueChanged();
});
var $linearizePointDistanceDisplay = document.getElementById('linearize-point-distance');
var $linearizePointDistance = document.getElementById('linearize-point-distance-slider');
$linearizePointDistance.addEventListener('input', function (e) {
    var target = e.target;
    var value = Number(target.value);
    $linearizePointDistanceDisplay.innerHTML = target.value;
    linearizePointDistance = value;
    onValueChanged();
});
var $curveFittingErrorDisplay = document.getElementById('curve-fitting-error');
var $curveFittingError = document.getElementById('curve-fitting-error-slider');
$curveFittingError.addEventListener('input', function (e) {
    var target = e.target;
    var value = Number(target.value);
    $curveFittingErrorDisplay.innerHTML = target.value;
    curveFittingError = value;
    onValueChanged();
});
var $ramerDouglaspeucherErrorDisplay = document.getElementById('ramer-douglas-peucher-error');
var $ramerDouglaspeucherError = document.getElementById('ramer-douglas-peucher-error-slider');
$ramerDouglaspeucherError.addEventListener('input', function (e) {
    var target = e.target;
    var value = Number(target.value);
    $ramerDouglaspeucherErrorDisplay.innerHTML = target.value;
    ramerDouglaspeucherError = value;
    onValueChanged();
});
var drawer = new drawer_1.Drawer($svg);
function onValueChanged() {
    drawer.options = {
        renderMode: renderMode,
        preprocessMode: preprocessMode,
        linearizePointDistance: linearizePointDistance,
        curveFittingError: curveFittingError,
        colorize: colorize,
    };
}

}();
/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=curves.min.js.map